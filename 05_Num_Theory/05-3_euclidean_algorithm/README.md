## 💡 유클리드 호제법

### ✔️ 유클리드 호제법
**유클리드 호제법**: 두 수의 `최대공약수(GCD)`를 구하는 알고리즘

### `GCD(A,B)=GCD(B,r)`
- 조건: A > B 가 성립하며 A ≡ r(mod B)

***

- 일반적으로 최대 공약수를 구하는 방법은 **소인수분해**를 이용한 공통된 소수들의 곱으로 표현함 -> 수가 커질수록 소인수분해 하기 어려워짐
- 유클리드 호제법을 사용하면 **나눗셈만 반복**하기 때문에 두 개의 수가 아무리 커도 정해진 순서대로 계산하면 효율적으로 GCD를 구할 수 있다.

-> `'두 수 p,q(p > q)의 공약수의 집합은 p - q와 q의 공약수 집합과 같다'`는 점을 이용할 것

- '%'으로만 연산을 해결하기 때문에 `p < q일때`의 입력이 들어올 경우 `p % q = p`이므로 **비교 연산자는 자동으로 필요없어지게 된다.**

~~(gcd(q, p)로 자동적으로 전환이 되는 것과 같아진다.)~~

+) **호제법**: 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘

***

### ✔️ 유클리드 호제법 핵심 이론
- MOD 연산: 두 값을 나눈 나머지를 구하는 연산

- 🚩 **MOD 연산으로 구현하는 유클리드 호제법**
>  - 1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
>  - 2. 앞 단계에서의 작은 수와 NOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
>  - 3. 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.

***

### ❕ 증명
- 두 정수 A, B (A>B) 의 최대공약수(GCD)를 `G`라고 하자. G는 공약수이므로 두 서로소 a, b에 대해 다음 식이 성립한다.
    - ### A = aG, B = bG
- A를 B로 나눈 나머지를 r, 몫을 q라고 하면 A = qB + r(0 ≤ r < |B|)를 만족한다. 이 식을 이용해 새로운 식을 전개해보면 다음과 같다.
    - ### aG = bGq + rr = G(a−qb)
- 이 때 `B와 r의 최대공약수가 G임`을 보이면 증명이 끝나는데, 이는 `b 와 a−qb가 서로소임`을 증명하는 것과 같다. `귀류법`을 사용하여 b와 a−qb가 서로소가 아니라고 가정해보자. *서로소가 아닐 경우* **2이상의 최대공약수가 존재**하며 그걸 p라고 하면 두 정수 n,m에 대하여 다음 식이 성립한다.
    - ### b = np, a − qb = mp
- `a − qb = mp`는 다시 `b = np`를 이용해 아래와 같이 전개할 수 있다.
    - ### a = qb + mp = qnp + mp = (qn+m)p
- 위 식에 의해서 a,b는 공약수인 p를 가지게 되는데 가장 처음에 가정했던 **a,b가 서로소라는 것에 모순**이 되기 때문에 `b, a−qb는 반드시 서로소`여야 한다. 따라서 `GCD(B,r) = G`가 성립한다.
