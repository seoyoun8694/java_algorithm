## 💡 확장 유클리드 호제법

### ✔️ 확장 유클리드 호제법
**`k ∗ k^−1 = 1 mod n (Assumption: gcd(k, n) = 1)`** 와 같은 수식에서 k의 역원인 `k^-1`를 찾아내기 위해 가장 간단한 방법은 *0~n-1까지 k^-1위치에 brute force 하는 것*인데, 암호 알고리즘 특성상 n의 크기가 커지는 경우가 생길 수 있고 그러면 그때 역원을 구하는 오버헤드가 너무 크다. 그 때 확장 유클리드 알고리즘을 사용한다.

- **확장 유클리드 알고리즘**: 모듈러 곱(modular multiplication) 연산의 inverse를 빠르게 찾게 하는 알고리즘

-> 결국 모듈러 곱 연산의 inverse가 존재한다고 가정한다면 r^2가 0일 때 r^1 이 1이 된다. 그리고 r^1이 1일 때 t^1이 modulo n의 곱셈에 대한 b의 inverse가 된다.

***

### ➕ 배주 항등식
+) 확장 유클리드 호제법: 베주 항등식의 명제를 가정으로 하여 해를 구하는 방법임

**`GCD(a,b) = d`** 라고 할 때,
1. ax + by = d를 만족하는 정수 x, y가 존재한다.
2. d는 정수 x, y에 대하여 `ax + b`y로 표현할 수 있는 **가장 작은 정수**이다.
3. `ax + by`로 표현될 수 있는 모든 정수는 **d의 배수**이다.

### ❕ 증명
- 둘 중 하나는 0이 아닌 정수 a,b에 대하여 집합 S를 다음과 같이 정의한다.
    - ### S = ax + by > 0 | x, y∈Z
- 집합 S는 위 정의에 따라 `자연수의 부분집합`이고, S가 *공집합이 아니라면* 자연수의 정렬성인 **"자연수의 부분집합이 공집합이 아닐 경우가장 작은 값을 원소로 가진다."** 이에 따라서 가장 작은 값을 원소로 가진다. 따라서 S가 공집합이 아니라는 것을 증명하면 **S가 ax + by로 나타낼수 있는 가장 작은 자연수를 원소로 가진다**는 사실을 증명할 수 있다.
    - ### |a| = a × 1 + b × 0 ∈ S (if a > 0) / a × -1 + b × 0 ∈ S (if a < 0) / 0, b ≠ 0 (if a = 0)
- 위 3가지 경우에 대해 모두 `|a|가 S에 속하기 때문에 |a|나 |b| 중 적어도 1개가 S에 속한다는 것`을 알 수 있다. 따라서 위에서 언급한자연수의 정렬성에 따라 **S는 ax + by로 나타냘 수 있는 가장 작은 자연수를 원소로 가지며**, 그것을 `d`라고 하자.
- 임의의 정수 k, l에 대해 `d = ak + bl`로 나타낼 수 있으며 **나눗셈 정리**에 따라서 S의 임의의 원소를 x라고 했을 때 `x = dq + r(0 ≤ r < d)`로 쓸 수 있다. 이 때 *x를 d의 배수가 아니라면 가정*하면 **r ≠ 0** 이므로 **자연수**라고 할 수 있고, **x가 S에 속하기 때문에** 임의의 정수 u, v에 대해 `x = au + bv`로 나타낼 수 있다. 이걸 종합해서 r에 대해 풀어쓰면 다음과 같다.
    - ### r = x − dq = (au + bv) − dq = (au + bv) − (ak + bl) q = au − akq + bv − blq = a (u − kq) + b (v − lq) ∈ S
- 이 때 `r`은 **d로 나눈 나머지이기 때문에 d보다 작은데, d의 정의가 S에서 가장 작은 자연수이므로 모순**이다. 따라서 처음에 가정했던 **“x가 d의 배수가 아니다” 라는 가정은 거짓**이 되므로 **`x는 d의 배수`** 이다. 여기서 `x`는 `S의 임의의 원소`이기 때문에 **S의 모든 원소는 d의 배수**이다. **|a|,|b| 중 적어도 하나는 S의 원소이기 때문에 d는 a,b의 공약수가 된다.**
- `GCD(a, b) = G, a = AG, b = BG`일 때, `d = ak + bl = AGk + BGl = G(Ak+Bl)`이 성립하므로 **d는 G의 배수**이다. 위에서 **d가 a,b의 공약수**였기 때문에 **d는 G의 약수이면서 배수**이게 된다. 따라서 **`d = G = GCD(a, b)가 성립`** 한다.

***

### ✔️ 확장 유클리드 호제법 _ 정의 -> 식 정리
- 베주 항등식에 따라서 `GCD(a, b) = d`라고 할 때 **`ax + by = d`를 만족하는 x,y가 존재**하며, 이는 유클리드 호제법의 과정을 역으로 따라가면 찾을 수 있다. 따라서, 유클리드 호제법의 과정을 따라가봐야 한다. 두 정수 a, b에 대해 나눗셈 정리와 유클리드 호제법을 반복하여 다음과 같이 나열할 수 있다.
    - ### a = bq0 + r1 , b = r1q1 + r2 , r1 = r2q2 + r3 , ... , ri − 1 = riqi + ri+1
- 여기서 `ri + 1 = ri−1 − riqi`를 얻을 수 있고 **`ri + 1 = 0`일 때 알고리즘이 종료**된다는 것을 알 수 있다. 여기서 `d`는 `ri`이므로 ax + by꼴로 나타내기 위해서 `r0 = a, r1 = b`라고 하면 `r0 = a × 1 + b × 0`이 되고 `r1 = a × 0 + b × 1`이 된다. 이는 **이후의 ri도 같은 꼴로 나타내어진다는 것**을 알 수 있다. 이 때 임의의 ri에 대해 a의 계수를 si, b의 계수를 ti라고 하면 아래와 같이 표현할 수 있다.
    - ### ri = sia + tib
- `ri + 1 = ri−1 − riqi` 에 대입하면 다음 점화식을 얻어낼 수 있다.
    - ### si+1a + ti+1b = (si−1a + ti−1b) − (sia + tib) qi = si−1a − siaqi + ti−1b − tibqi = (si−1 − siqi) a + (ti−1 − tiqi) b
- 총 정리하면 다음과 같다.
    - ### r0=a, r1=b / s0=1, s1=0 / t0=0, t1=1 / ri+1=ri−1−riqi / si+1=si−1−siqi / ti+1=ti−1−tiqi
